// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

model Example {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Necessary for Next auth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  password          String?
  refresh_token     String? // @db.Text
  access_token      String? // @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? // @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Subscription {
  id             String    @id @default(cuid())
  userId         String    @unique
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  isTrial        Boolean
  isActive       Boolean
  isCanceled     Boolean
  isPaused       Boolean
  isPending      Boolean
  isExpired      Boolean
  isLifetime     Boolean
  subscriptionId String?
  expiresAt      DateTime?
  user           User      @relation(fields: userId, references: id, onDelete: Cascade)
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Photographer {
  id              String           @id @default(cuid())
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId          String           @unique
  name            String
  location        String
  bio             String?
  avatar          String?
  website         String?
  instagram       String?
  facebook        String?
  twitter         String?
  youtube         String?
  tiktok          String?
  vimeo           String?
  portfolioImages PortfolioImage[]
  reviews         Review[]
  companyName     String
  events          Event[]

  // Search performance indexes
  @@index([name])
  @@index([location])
  // Note: bio field uses LIKE/contains queries which can't be fully optimized with standard indexes
  // For production scale, consider:
  // 1. Full-text search (FTS5 for SQLite/D1)
  // 2. External search service (Algolia, Meilisearch, Typesense)
  // 3. Limit search to indexed fields only
  @@index([companyName])
}

model PortfolioImage {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  photographer   Photographer @relation(fields: [photographerId], references: [id], onDelete: Cascade)
  photographerId String
  image          String
  title          String
  description    String?
  tags           String // JSON-serialized array for SQLite compatibility
  isFeatured     Boolean
  isDeleted      Boolean      @default(false)
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  targetId  String
}

model Review {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  photographer   Photographer @relation(fields: [photographerId], references: [id], onDelete: Cascade)
  photographerId String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  rating         Int
  title          String
  description    String?
}

model MessageThread {
  id           String    @id @default(cuid())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  participants User[]
  messages     Message[]
  match        Match?
}

model Message {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  thread    MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  threadId  String
  sender    User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId  String
  content   String
  isRead    Boolean       @default(false)
  isDeleted Boolean       @default(false)
}

model User {
  id                String          @id @default(cuid())
  firstName         String
  lastName          String
  handle            String?         @unique
  email             String          @unique
  emailVerified     DateTime?
  profilePic        String?
  phone             String?
  address           String?
  city              String?
  state             String?
  zip               String?
  country           String?
  accounts          Account[]
  sessions          Session[]
  subscription      Subscription?
  photographer      Photographer?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  favorites         Favorite[]
  reviews           Review[]
  messages          Message[]
  messageThreads    MessageThread[]
  comments          Comment[]
  stripeId          String?         @unique
  commentLikes      CommentLike[]
  eventLike         EventLike[]
  bookingsApplied   Booking[]       @relation("BookingApplicant")
  bookingsOwned     Booking[]       @relation("BookingOwner")
  notifications     Notification[]
  referralsSent     Referral[]      @relation("ReferralReferrer")
  referralsReceived Referral[]      @relation("ReferralReferred")
  swipesSent        Swipe[]         @relation("SwipesSent")
  swipesReceived    Swipe[]         @relation("SwipesReceived")
  matchesAsUser1    Match[]         @relation("MatchesAsUser1")
  matchesAsUser2    Match[]         @relation("MatchesAsUser2")
  isDiscoverable    Boolean         @default(false)
  seekingTypes      String?         // JSON array: ["wedding", "portrait", "event", "commercial"]
  budgetMin         Int?
  budgetMax         Int?
}

model Event {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  photographer   Photographer @relation(fields: [photographerId], references: [id], onDelete: Cascade)
  photographerId String
  title          String
  description    String?
  location       String
  date           DateTime
  duration       Int          @default(1) // In hours
  image          String?
  isFulfilled    Boolean      @default(false)
  isDeleted      Boolean      @default(false)
  comments       Comment[]
  eventLikes     EventLike[]
  bookings       Booking[]
  // Note: description field uses LIKE/contains queries which can't be fully optimized with standard indexes
  // For production scale, consider full-text search (FTS5) or external search service

  // Search performance indexes
  @@index([title])
  @@index([location])
  @@index([date])
  @@index([isDeleted, date]) // Composite index for common filter pattern
}

model EventLike {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  eventId   String
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isDeleted Boolean  @default(false)
}

model Comment {
  id           String        @id @default(cuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  eventId      String
  event        Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId       String
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  content      String
  isDeleted    Boolean       @default(false)
  commentLikes CommentLike[]
}

model CommentLike {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  isDeleted Boolean  @default(false)
}

model Booking {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId     String
  applicant   User     @relation("BookingApplicant", fields: [applicantId], references: [id], onDelete: Cascade)
  applicantId String
  owner       User     @relation("BookingOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId     String
  status      String   @default("applied") // applied, accepted, declined, completed, canceled
  rate        String? // Proposed rate
  notes       String? // Message from applicant
  ownerNotes  String? // Response from event owner
  isDeleted   Boolean  @default(false)

  @@unique([eventId, applicantId])
  @@index([applicantId, status])
  @@index([ownerId, status])
  @@index([eventId])
}

model Notification {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  recipient   User     @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId String
  type        String // booking_applied, booking_accepted, booking_declined, booking_completed, new_message, review_received, profile_view
  title       String
  body        String
  isRead      Boolean  @default(false)
  linkUrl     String? // Deep link to relevant page
  data        String? // JSON-serialized extra data

  @@index([recipientId, isRead])
  @@index([recipientId, createdAt])
}

model Referral {
  id         String    @id @default(cuid())
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  referrer   User      @relation("ReferralReferrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referrerId String
  referred   User?     @relation("ReferralReferred", fields: [referredId], references: [id], onDelete: Cascade)
  referredId String?
  code       String    @unique
  status     String    @default("pending") // pending, signed_up, rewarded, expired
  rewardType String? // free_month, credit
  rewardedAt DateTime?

  @@index([referrerId])
  @@index([code])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Swipe {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  swiperId  String
  targetId  String
  direction String   // "like" | "pass"
  swiper    User     @relation("SwipesSent", fields: [swiperId], references: [id], onDelete: Cascade)
  target    User     @relation("SwipesReceived", fields: [targetId], references: [id], onDelete: Cascade)

  @@unique([swiperId, targetId])
  @@index([swiperId])
  @@index([targetId, direction])
}

model Match {
  id              String         @id @default(cuid())
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  user1Id         String
  user2Id         String
  status          String         @default("matched") // matched, messaged, booked, expired
  messageThreadId String?        @unique
  aiSummary       String?
  expiresAt       DateTime?
  user1           User           @relation("MatchesAsUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2           User           @relation("MatchesAsUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messageThread   MessageThread? @relation(fields: [messageThreadId], references: [id])

  @@unique([user1Id, user2Id])
  @@index([user1Id, status])
  @@index([user2Id, status])
}
